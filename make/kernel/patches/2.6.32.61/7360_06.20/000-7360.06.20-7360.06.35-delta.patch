This patch has been created from AVM's opensrc packages for 7360.06.20 and 7360.06.35
by applying to the kernel sources they contain the following command:

    diff -durN --no-dereference 7360.06.20 7360.06.35 > this.patch

--- linux-2.6.32/drivers/char/avm_new/Makefile	2015-03-17 15:39:29.000000000 +0200
+++ linux-2.6.32/drivers/char/avm_new/Makefile	2019-08-14 16:52:39.000000000 +0200
@@ -1,6 +1,6 @@
 #############################################
 # Makefile: automaticly generated by ./init_avm
-#           Di 17. MÃ¤r 15:39:29 CET 2015
+#           Mi 14. Aug 16:52:39 CEST 2019
 #############################################
 
 #############################################
--- linux-2.6.32/drivers/char/dect_io/init_dect_io	2006-09-07 15:55:01.000000000 +0200
+++ linux-2.6.32/drivers/char/dect_io/init_dect_io	2016-04-11 13:12:11.000000000 +0200
@@ -9,7 +9,7 @@
 
 for i in `find . -name Makefile.$KERNEL_CLASS` ; do
     dest=${i%.$KERNEL_CLASS}
-    source="`pwd`/$i"
+    source="${i##*/}"
     rm -f $dest
     ln -fvs $source $dest
 done
--- linux-2.6.32/drivers/char/flash_update/init_flash_update	2005-12-05 13:13:30.000000000 +0100
+++ linux-2.6.32/drivers/char/flash_update/init_flash_update	2016-04-11 13:10:26.000000000 +0200
@@ -9,7 +9,7 @@
 
 for i in `find . -name Makefile.$KERNEL_CLASS` ; do
     dest=${i%.$KERNEL_CLASS}
-    source="`pwd`/$i"
+    source="${i##*/}"
     rm -f $dest
     ln -fvs $source $dest
 done
--- linux-2.6.32/drivers/char/Piglet_noemif/init_Piglet	2006-01-17 13:00:39.000000000 +0100
+++ linux-2.6.32/drivers/char/Piglet_noemif/init_Piglet	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
-#! /bin/sh
-
-KERNEL_CLASS=$1
-DRIVER_NAME=$2
-
-if [ -z "$KERNEL_CLASS" ] ; then
-    KERNEL_CLASS=26
-fi
-
-for i in `find . -name Makefile.$KERNEL_CLASS` ; do
-    dest=${i%.$KERNEL_CLASS}
-    source="`pwd`/$i"
-    rm -f $dest
-    ln -fvs $source $dest
-done
-
-exit 0
--- linux-2.6.32/drivers/char/Piglet_noemif/init_Piglet_noemif	2007-06-13 19:35:58.000000000 +0200
+++ linux-2.6.32/drivers/char/Piglet_noemif/init_Piglet_noemif	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
-#! /bin/sh
-
-KERNEL_CLASS=$1
-DRIVER_NAME=$2
-
-if [ -z "$KERNEL_CLASS" ] ; then
-    KERNEL_CLASS=26
-fi
-
-for i in `find . -name Makefile.$KERNEL_CLASS` ; do
-    dest=${i%.$KERNEL_CLASS}
-    source="`pwd`/$i"
-    rm -f $dest
-    ln -fvs $source $dest
-done
-
-exit 0
--- linux-2.6.32/drivers/char/Piglet_noemif/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.32/drivers/char/Piglet_noemif/Kbuild	2018-10-09 08:53:53.000000000 +0200
@@ -0,0 +1 @@
+# Empty kbuild dummy
--- linux-2.6.32/drivers/char/Piglet_noemif/Makefile.24	2005-11-04 09:41:12.000000000 +0100
+++ linux-2.6.32/drivers/char/Piglet_noemif/Makefile.24	1970-01-01 01:00:00.000000000 +0100
@@ -1,9 +0,0 @@
-###################################################################################################################
-#
-#   vim: noexpandtab
-#
-#	dummy Makefile with no function
-#
-###################################################################################################################
-
-include $(TOPDIR)/Rules.make
--- linux-2.6.32/drivers/char/Piglet_noemif/Makefile.26	2005-11-04 09:18:32.000000000 +0100
+++ linux-2.6.32/drivers/char/Piglet_noemif/Makefile.26	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-###################################################################################################################
-#
-#   vim: noexpandtab
-#
-#	dummy Makefile with no function
-#
-###################################################################################################################
-
--- linux-2.6.32/drivers/char/ubik2/Kconfig	2010-03-05 11:04:06.000000000 +0100
+++ linux-2.6.32/drivers/char/ubik2/Kconfig	2016-08-22 16:41:35.000000000 +0200
@@ -0,0 +1,4 @@
+config UBIK2_ISDNSTACK_ON_CPU
+    int
+	default 0
+
--- linux-2.6.32/drivers/char/ubik2/linux_pcmlink_ul.h	2012-08-13 18:36:23.000000000 +0200
+++ linux-2.6.32/drivers/char/ubik2/linux_pcmlink_ul.h	2017-02-06 14:38:06.000000000 +0100
@@ -4,11 +4,10 @@
 #define __linux_pcmlink_ul_h__
 
 #include <linux/types.h> 
-/*--------------------------------------------------------------------------------*\
-\*--------------------------------------------------------------------------------*/
-enum _logic_chan_ll {
-   logic_chan_isdn = 0
-};
+#include <linux/module.h> 
+#include <linux/sched.h> 
+#include <linux/interrupt.h>
+#include <linux/slab.h> 
 
 /*------------------------------------------------------------------------------------------*\
 \*------------------------------------------------------------------------------------------*/
@@ -35,7 +34,7 @@
 #define PCMLINK_MAX_DYNHW_CHAN      3
 /*-------------------------------------------------------------------------------------*\
 \*-------------------------------------------------------------------------------------*/
-enum _chan_message_voip_config{
+enum _chan_message_voip_config {
     voip_chanx_off           = 0,
     voip_chanx_8khz          = 1,
     voip_chanx_8khz_only_rcv = 2
@@ -93,8 +92,8 @@
 #define PCMBUS_MAX_AUDIOCHAN(a) ((((a)->SupportFlag) >> 26) & 0x03)
 #define PCMBUS_MAX_ECCHAN(a)    ((((a)->SupportFlag) >> 22) & 0x0F)
 #define PCMBUS_MAX_CODECCHAN(a) ((((a)->SupportFlag) >> 17) & 0x1F)
-#define PCMBUS_MAX_TECHAN(a)    ((((a)->SupportFlag) >> 13) & 0x0F)
-#define PCMBUS_MAX_NTCHAN(a)    ((((a)->SupportFlag) >>  9) & 0x0F)
+#define PCMBUS_MAX_NTCHAN(a)    ((((a)->SupportFlag) >> 13) & 0x0F)
+#define PCMBUS_MAX_TECHAN(a)    ((((a)->SupportFlag) >>  9) & 0x0F)
 #define PCMBUS_MAX_DECTCHAN(a)  ((((a)->SupportFlag) >>  5) & 0x0F)
 #define PCMBUS_MAX_SLICCHAN(a)  ((((a)->SupportFlag) >>  2) & 0x07)
 #define PCMBUS_MAX_POTSCHAN(a)  ((((a)->SupportFlag) >>  1) & 0x01)
@@ -174,14 +173,21 @@
 void pcmlink_ul_dspfwversion_pcmrouter(struct _chan_configmsg_dsptomips **fwversion);
 
 /*--------------------------------------------------------------------------------*\
+ * nur fuer ISDN-Treiber: liefere Codecnames (TDM-Bus abhaengig)
+\*--------------------------------------------------------------------------------*/
+int pcmlink_ul_codectdmbus(char *table[], unsigned int maxentries);
+
+/*--------------------------------------------------------------------------------*\
  * nur fuer dect-Treiber:
  * maxslotlen: liefert maximale Slotlaenge
  * p[maxdectslots] : Pointertabelle: hier Daten hineinschreiben/lesen - Pointer nicht modifizieren!
  * Achtung es muessen immer auch die (Dummy-)Daten fuer Tx komplett geschrieben werden!
  * Returnwert: Handle
+ *
+ * Returnwert der RxTxCallback: 0 success, 1 fehlerhafte Daten detektiert
 \*--------------------------------------------------------------------------------*/
 void *pcmlink_ul_register_dectcontrol(unsigned int *maxslotlen, unsigned int *maxdectslots,
-                                      void RxTxCallback(unsigned char **p_rx, unsigned char **p_tx));
+                                      int RxTxCallback(unsigned char **p_rx, unsigned char **p_tx));
 
 /*--------------------------------------------------------------------------------*\
  * nur fuer dect-Treiber:
@@ -204,12 +210,14 @@
  *              ptxslottab[]: Slotzeigertabelle fuer zum PCM-Bus zu verschickende Daten - 
  *                            im Aufruf zu fuellen 
  *              slotlen:      Laenge der Daten pro Slot in Byte
+ *              flag:         0x0: alles ok
+ *                            0x1: trigger too late erkannt (CELT-Resync-notwendig)  
  *
  *  Returnparameter: Slothandle            
  *              NULL: falls Slots bereits belegt/Konflikte mit vergebenen Slots/der Isdn-Treiber nicht laeuft
 \*--------------------------------------------------------------------------------*/
 void *pcmlink_ul_openslots(void *linkhandle, void *ref, 
-                           void (*RxTxCallback)(void *ref, short slotentries, unsigned char *prxslottab[], unsigned char *ptxslottab[], size_t slotlen),
+                           void (*RxTxCallback)(void *ref, short slotentries, unsigned char *prxslottab[], unsigned char *ptxslottab[], size_t slotlen, unsigned int flag),
                            unsigned int transp_flag
                           );
 
@@ -279,5 +287,300 @@
  * Meldet HwChannel-Support am PCM-Router ab
 \*--------------------------------------------------------------------------------*/
 void pcmlink_ul_release_dynhwchannel_control(void *handle);
+
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+enum _pcmlink_status_operation {
+    slic_check,
+    slic_status,
+    slic_frequency,
+    slic_coefficients,
+    set_hw_cross,
+    unset_hw_cross,
+    hw_cross_noavail,
+	codecs_onoff,
+    dect_slotlen,
+    slot_mute,
+};
+/*--------------------------------------------------------------------------------*\
+ * slic_check:         ret: Anzahl der Slics (falls so ermittelbar)
+ * slic_status:        arg1: Slot
+ *                     arg2: veroderte Bits (s.u. SLIC_CODEC_... )
+ * slic_frequency:     Setze Slic-Klingelfrequenz arg1: Frequenz 
+ * slic_coefficients:  arg1: Koeffizienten-Index
+ * set_hw_cross: arg1 = ulchan1
+ *				 arg2 = ulchan2
+ *				 ret: -1 Hw-Cross Einstellungen muessen nach "alter" registerbasierter Loesung erfolgen
+ *				 0: ok
+ *				 1: dieser Channel kann nicht per HWCross geschaltet werden
+ * unset_hw_cross:   arg1 = ulchan1 (ret s.o.)
+ * hw_cross_noavail: ret: 0 Anbindung ist Hw-Cross-faehig
+ * codecs_onoff: arg1 ulchan arg2 veroderbar Bit0: rx Bit1 tx
+ * Hw-abhaengiger Support: 
+ * slic_check          pef
+ * slic_status         pef, adsp
+ * slic_frequency      pef( 25 Hz, 50 Hz), adsp (fast beliebige Frequenz)
+ * slic_coefficients:  pef (Koeffizienten-Index 0: 3 dB 1: 0 dB)
+\*--------------------------------------------------------------------------------*/
+#define SLIC_CODEC_POWERDOWN                                 0x0000
+#define SLIC_CODEC_POWERUP                                   0x0001
+#define SLIC_CODEC_RING                                      0x0002
+#define SLIC_CODEC_CLIP                                      0x0004
+#define SLIC_CODEC_POLREV                                    0x0008
+
+/*--------------------------------------------------------------------------------*\
+ * generelle Funktion fuer ISDN-Treiber um Stati abzufragen/setzen
+ * Diese Funktion soll langfristig das Setzen von Registern abloesen
+ * Returnwert: Operations-spezifisch
+ *			   generell: < 0 nicht supported 
+\*--------------------------------------------------------------------------------*/
+int pcmlink_ul_status(enum _pcmlink_status_operation operation, unsigned int arg1, unsigned int arg2);
+
+#include <linux/version.h>
+#include <linux/spinlock.h>
+#if defined(CONFIG_AVM_IPI_YIELD)
+#include <asm/yield_context.h>
+#include <linux/simple_mempool.h>
+#endif/*--- #if defined(CONFIG_AVM_IPI_YIELD) ---*/
+
+#if defined(CONFIG_AVM_IPI_YIELD)
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_lock_init(spinlock_t *lock) {
+  yield_spin_lock_init(lock);
+}
+/*--------------------------------------------------------------------------------*\
+ * Speziallock: ist auch aus non-Linux-TC-Kontext aufrufbar 
+ * (soweit von Hardware unterstuetzt)
+ * wenn flags == NULL: keine Irqs sperren
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_lock(spinlock_t *lock, unsigned long *flags) {
+    if(flags) {
+        yield_spin_lock_irqsave(lock, *flags);
+    } else {
+        yield_spin_lock(lock);
+    }
+}
+/*--------------------------------------------------------------------------------*\
+ * wenn flags == NULL: keine Irqs restoren 
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_unlock(spinlock_t *lock, unsigned long *flags) {
+    if(flags) {
+        yield_spin_unlock_irqrestore(lock, *flags);
+    } else {
+        yield_spin_unlock(lock);
+    }
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline int pcmlink_ul_yieldcontext(void) {
+    return !yield_is_linux_context();
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline int pcmlink_ul_assert_on_yield_context(void) {
+    if(pcmlink_ul_yieldcontext()) {
+        printk(KERN_ERR"\nGREAT-ERROR: Do not use in Yield-Context pc=%pS ra=%pS\n", (void *)_THIS_IP_, (void *)_RET_IP_);
+        return 1;
+    }
+    return 0;
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void *pcmlink_ul_malloc(void *memhandle, unsigned int size) {
+    return simplemempool_alloc(memhandle, size, 0, (void *)_RET_IP_);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void *pcmlink_ul_zalloc(void *memhandle, unsigned int size) {
+    return simplemempool_alloc(memhandle, size, 1, (void *)_RET_IP_);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_mfree(void *memhandle, void *ptr) {
+    simplemempool_free(memhandle, ptr, (void *)_RET_IP_);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_wake_up_interruptible(wait_queue_head_t *q){
+    yield_wake_up_interruptible(q);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_wake_up(wait_queue_head_t *q){
+    yield_wake_up(q);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline bool pcmlink_ul_schedule_work(struct work_struct *work) {
+    return yield_schedule_work(work);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline bool pcmlink_ul_queue_work_on(int cpu, struct workqueue_struct *wq, struct work_struct *work){
+    return yield_queue_work_on(cpu, wq, work);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline bool pcmlink_ul_schedule_delayed_work(struct delayed_work *dwork, unsigned long delay) {
+    return yield_schedule_delayed_work(dwork, delay);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_tasklet_hi_schedule(struct tasklet_struct *t) {
+    yield_tasklet_hi_schedule(t);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline bool pcmlink_ul_try_module_get(struct module *module) {
+    return yield_try_module_get(module);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_module_put(struct module *module) {
+    yield_module_put(module);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void *pcmlink_ul_alloc_init(char *pool_name, unsigned int pool_size){
+    return simplemempool_alloc_init(pool_name, pool_size);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_alloc_exit(void *pmp){
+    simplemempool_alloc_exit(pmp);
+}
+
+#else /*--- #if defined(CONFIG_AVM_IPI_YIELD) ---*/
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_lock_init(spinlock_t *lock) {
+  spin_lock_init(lock);
+}
+/*--------------------------------------------------------------------------------*\
+ * Speziallock: ist auch aus non-Linux-TC-Kontext aufrufbar 
+ * (soweit von Hardware unterstuetzt)
+ * wenn flags == NULL: keine Irqs sperren
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_lock(spinlock_t *lock, unsigned long *flags) {
+    if(flags) {
+        spin_lock_irqsave(lock, *flags);
+    } else {
+        spin_lock(lock);
+    }
+}
+/*--------------------------------------------------------------------------------*\
+ * wenn flags == NULL: keine Irqs restoren 
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_unlock(spinlock_t *lock, unsigned long *flags) {
+    if(flags) {
+        spin_unlock_irqrestore(lock, *flags);
+    } else {
+        spin_unlock(lock);
+    }
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline int pcmlink_ul_yieldcontext(void) {
+    return 0;
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline int pcmlink_ul_assert_on_yield_context(void) {
+    return 0;
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void *pcmlink_ul_malloc(void *dummy __maybe_unused, unsigned int size) {
+    return kmalloc(size, GFP_ATOMIC);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void *pcmlink_ul_zalloc(void *dummy __maybe_unused, unsigned int size) {
+    return kzalloc(size, GFP_ATOMIC);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_mfree(void *dummy __maybe_unused, void *ptr) {
+    kfree(ptr);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_wake_up_interruptible(wait_queue_head_t *q){
+    wake_up_interruptible(q);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_wake_up(wait_queue_head_t *q){
+    wake_up(q);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline bool pcmlink_ul_schedule_work(struct work_struct *work) {
+    return schedule_work(work);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline bool pcmlink_ul_queue_work_on(int cpu, struct workqueue_struct *wq, struct work_struct *work){
+    return queue_work_on(cpu, wq, work);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline bool pcmlink_ul_schedule_delayed_work(struct delayed_work *dwork, unsigned long delay) {
+    return schedule_delayed_work(dwork, delay);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_tasklet_hi_schedule(struct tasklet_struct *t) {
+    tasklet_hi_schedule(t);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline bool pcmlink_ul_try_module_get(struct module *module) {
+    return try_module_get(module);
+}
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_module_put(struct module *module) {
+    module_put(module);
+}
+/*--------------------------------------------------------------------------------*\
+ * nur dummy - aber handle zurueckliefern
+\*--------------------------------------------------------------------------------*/
+static inline void *pcmlink_ul_alloc_init(char *pool_name __maybe_unused, unsigned int pool_size __maybe_unused){
+    return kmalloc(4, GFP_KERNEL);
+}
+/*--------------------------------------------------------------------------------*\
+ * nur dummy
+\*--------------------------------------------------------------------------------*/
+static inline void pcmlink_ul_alloc_exit(void *pmp){
+    kfree(pmp);
+}
+#endif/*--- #else  ---*//*--- #if defined(CONFIG_AVM_IPI_YIELD) ---*/
+
+/*--------------------------------------------------------------------------------*\
+ * Registriert die DECT-Slot-Callback fuer den DECT-Daten-Pfad (non-PCM)
+ * ref: private Data (!=NULL)
+ * DECTSlotIngressCallback: Callback Daten zum Stub
+ * DECTSlotEgressCallback:  Callback Daten vom Stub
+ *
+ * Return-Parameter: > = Laenge der Daten pro Slot in Byte
+ *                       sonst Fehler
+ * Callbacks mit folgenden Parametern:
+ *          ref:            private Data
+ *          slot:           beginnend mit 1 !
+ *          ingress_data:   Pointer auf Daten zum DECT-Stub (umkopieren erforderlich)
+ *          eggress_data:   hier die Daten reinkopieren
+ * 
+ * Format der Daten: bei G722 alle 16 Bit Werte verdoppelt ( 128 kBit)
+\*--------------------------------------------------------------------------------*/
+int Register_DECTSlot_Callback(void *ref,
+                               void (*DECTSlotIngressCallback)(void *ref, unsigned int dectslot, const unsigned short *ingress_data),
+                               void (*DECTSlotEgressCallback)(void *ref, unsigned int dectslot, const unsigned short *egress_data));
+
+/*--------------------------------------------------------------------------------*\
+ * DECT-Slot-Callbacks abmelden
+\*--------------------------------------------------------------------------------*/
+void Release_DECTSlot_Callback(void *ref);
 #endif/*--- #if defined(__KERNEL__) ---*/
 #endif/*--- #ifndef __linux_pcmlink_ul_h__ ---*/
--- linux-2.6.32/drivers/isdn/avm_dect/init_avm_dect	2007-05-16 12:07:16.000000000 +0200
+++ linux-2.6.32/drivers/isdn/avm_dect/init_avm_dect	2016-04-11 13:15:36.000000000 +0200
@@ -9,7 +9,7 @@
 
 for i in `find . -name Makefile.$KERNEL_CLASS` ; do
     dest=${i%.$KERNEL_CLASS}
-    source="`pwd`/$i"
+    source="${i##*/}"
     rm -f $dest
     ln -fvs $source $dest
 done
--- linux-2.6.32/drivers/isdn/isdn_fon5/init_isdn	2005-11-04 08:57:30.000000000 +0100
+++ linux-2.6.32/drivers/isdn/isdn_fon5/init_isdn	2016-04-12 11:30:06.000000000 +0200
@@ -9,7 +9,7 @@
 
 for i in `find . -name Makefile.$KERNEL_CLASS` ; do
     dest=${i%.$KERNEL_CLASS}
-    source="`pwd`/$i"
+    source="${i##*/}"
     rm -f $dest
     ln -fvs $source $dest
 done
--- linux-2.6.32/drivers/serial/serial_avm_asc.c	2014-07-15 17:50:49.000000000 +0200
+++ linux-2.6.32/drivers/serial/serial_avm_asc.c	2014-10-27 16:15:09.000000000 +0100
@@ -15,6 +15,7 @@
 #define WORKAROUND_ACK_TIR_ON_ENTRY
 #define WORKAROUND_ACK_RIR_ON_ENTRY
 #define WORKAROUND_GEN_MISSING_ENABLE_TX_IRQ
+#define WORKAROUND_GEN_MISSING_TX_IRQ
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/addrspace.h>
@@ -45,18 +46,12 @@
 	struct ifx_asc_port_priv *priv = (struct ifx_asc_port_priv *)port_priv_data->port_specificdata;
     ifx_asc_reg_t *asc_reg = priv->base;
 
-	unsigned int fifocnt;
-	fifocnt = (asc_reg->asc_fstat & ASCFSTAT_TXFREEMASK) >> ASCFSTAT_TXFREEOFF;
-	if (( fifocnt == 0 ) && !(asc_reg->asc_irnicr & IFX_ASC_IRQ_LINE_TIR) ){
-#if defined(WORKAROUND_GEN_MISSING_ENABLE_TX_IRQ)
-        asc_reg->asc_irnicr |= IFX_ASC_IRQ_LINE_TIR;
-#endif
-        tx_bugfix_count_enable ++;
-	}
+	unsigned int fifofree;
+	fifofree = (asc_reg->asc_fstat & ASCFSTAT_TXFREEMASK) >> ASCFSTAT_TXFREEOFF;
 
     asc_reg->asc_irnen |= IFX_ASC_IRQ_LINE_TIR;
 
-	if (( fifocnt == 0 ) && !(asc_reg->asc_irnicr & IFX_ASC_IRQ_LINE_TIR) ){
+	if ( fifofree && !(asc_reg->asc_irnicr & IFX_ASC_IRQ_LINE_TIR) ){
 #if defined(WORKAROUND_GEN_MISSING_ENABLE_TX_IRQ)
         asc_reg->asc_irnicr |= IFX_ASC_IRQ_LINE_TIR;
 #endif
@@ -257,7 +252,7 @@
 
 	if (uart_circ_empty(xmit)) {
 		uart_avm_stop_tx(port);
-    } else if ((( asc_reg->asc_fstat & ASCFSTAT_TXFREEMASK ) >> ASCFSTAT_TXFREEOFF ) == 0 ) {
+    } else if ((( asc_reg->asc_fstat & ASCFSTAT_TXFREEMASK ) >> ASCFSTAT_TXFREEOFF )) {
 
         mb();
 
--- linux-2.6.32/net/avm_pa/avm_pa.c	2015-03-17 15:39:29.000000000 +0200
+++ linux-2.6.32/net/avm_pa/avm_pa.c	2015-05-05 11:24:58.000000000 +0200
@@ -382,8 +382,6 @@
 
 #define AVM_PA_PRIOACK_THRESH_PKTS   40   /* wait for X packets to do the TCP-ACK check */
 #define AVM_PA_PRIOACK_RATIO         70   /* % of packets have to be TCP-ACKs for positive check */
-#define AVM_PA_PRIOACK_PACKET_SIZE   120  /* packet-size to recognize a packet as TCP-ACK */
-#define AVM_PA_PRIOACK_PRIORITY      4    /* priority for TCP-ACK packets */
 
 /* ------------------------------------------------------------------------ */
 
@@ -402,10 +400,14 @@
                               tx_channel_activated:1,
                               rx_channel_stopped:1,
    /* prioack handling */
-                              prioack_enabled:1;
+                              prioack_enabled:1,
+                              tget_enabled:1; /* tget = turbo HTTP-GET */
    unsigned int               prioack_priority;
    unsigned                   prioack_acks;
    unsigned                   prioack_accl_acks;
+   unsigned int               tget_priority;
+   unsigned                   tgets;
+   unsigned                   tget_accl;
    
    /* stats */
    u32                        tx_pkts;
@@ -523,7 +525,6 @@
    unsigned                  tok_rate[TOK_SAMLES];
    unsigned                  tok_pps[TOK_SAMLES];
    unsigned long             tok_overlimit[TOK_SAMLES];
-   unsigned                  prioack_packet_size;
    unsigned                  prioack_thresh_packets;
    unsigned                  prioack_ratio;
    struct avm_hardware_pa    hardware_pa;
@@ -563,7 +564,6 @@
    .ewma_log = AVM_PA_EST_DEFAULT_EWMA_LOG,
    .cputime_est_idx = AVM_PA_CPUTIME_EST_DEFAULT_IDX,
    .cputime_ewma_log = AVM_PA_CPUTIME_EST_DEFAULT_EWMA_LOG,
-   .prioack_packet_size = AVM_PA_PRIOACK_PACKET_SIZE,
    .prioack_thresh_packets = AVM_PA_PRIOACK_THRESH_PKTS,
    .prioack_ratio = AVM_PA_PRIOACK_RATIO,
 };
@@ -1931,9 +1931,25 @@
    struct avm_pa_pkt_info *info = AVM_PKT_INFO(pkt);
 
    if (egress->not_local) {
-      if (pid->prioack_enabled && info->match.ack_only) {
-         egress->tcpack_pkts++;
-         pkt->priority =  pid->prioack_priority;
+      if (pid->prioack_enabled) {
+         if (info->match.ack_only) {
+            egress->tcpack_pkts++;
+            pkt->priority =  pid->prioack_priority;
+#if AVM_PA_TRACE
+            if (ctx->dbgprioacktrace)
+                pa_printk(KERN_DEBUG, "avm_pa: %lu - _pa_transmit(%s), reset tcpack prio to 0x%X\n",
+                          pkt->uniq_id & 0xffffff, pid->cfg.name, pkt->priority);
+#endif
+         } else if (pid->tget_enabled && (info->match.pkttype & AVM_PA_PKTTYPE_PROTO_MASK) == IPPROTO_TCP && egress->tx_pkts < ctx->prioack_thresh_packets) {
+            pkt->priority =  pid->tget_priority;
+#if AVM_PA_TRACE
+            if (ctx->dbgprioack)
+                pa_printk(KERN_DEBUG, "avm_pa: %lu - _pa_transmit(%s), reset tget prio to 0x%X\n",
+                          pkt->uniq_id & 0xffffff, pid->cfg.name, pkt->priority);
+#endif
+         } else {
+            pkt->priority = egress->output.priority;
+         }
       } else  {
          pkt->priority = egress->output.priority;
       }
@@ -1978,8 +1994,8 @@
       skb_set_network_header(pkt, egress->push_l2_len);
 #if AVM_PA_TRACE
       if (ctx->dbgtrace)
-         pa_printk(KERN_DEBUG, "avm_pa: %lu - _pa_transmit(%s)\n",
-                               pkt->uniq_id & 0xffffff, pid->cfg.name);
+         pa_printk(KERN_DEBUG, "avm_pa: %lu - _pa_transmit(%s), prio=0x%X, info->match.ack_only=%d\n",
+                               pkt->uniq_id & 0xffffff, pid->cfg.name, pkt->priority, info->match.ack_only);
 #endif
       (*pid->cfg.tx_func)(pid->cfg.tx_arg, pkt);
    } else {
@@ -2934,6 +2950,12 @@
          if (pid->prioack_enabled) {
             /*--- prompt = "ack prio pkts"; ---*/
             snprintf(buf, sizeof(buf), "%u (accl acks %u)", pid->prioack_acks, pid->prioack_accl_acks);
+            (*fprintffunc)(arg, "%-10s: %s\n", prompt, buf);
+         }
+         if (pid->tget_enabled) {
+            /*--- prompt = "ack prio pkts"; ---*/
+            snprintf(buf, sizeof(buf), "%u (accl %u)", pid->tgets, pid->tget_accl);
+            (*fprintffunc)(arg, "%-10s: %s\n", prompt, buf);
          }
       } else {
          prompt = "Dest";
@@ -3937,10 +3959,12 @@
    struct avm_pa_vpid *evpid;
    struct ethhdr *ethh;
    unsigned int orig_packet_prio;
+   unsigned int set_tget_prio;
    unsigned negress;
    int headroom;
    char buf[64];
    u32 hash; /* not used uninitialized */
+   int do_tget = 0;
 
 #if AVM_PA_TRACE
    if (ctx->dbgtrace) {
@@ -3959,25 +3983,33 @@
    
    if (!sk) {
       if (epid->prioack_enabled) {
+         int is_tcp = ((info->match.pkttype & AVM_PA_PKTTYPE_PROTO_MASK) == IPPROTO_TCP) ? 1 : 0;
          if (ctx->dbgprioacktrace) {
-            printk(KERN_DEBUG "avm_pa_pid_snoop_transmit: info->match.syn=%d, info->match.ack_only=%d, PKT_LEN(pkt)=%d, pkt->priority=%x\n", 
-                   info->match.syn, info->match.ack_only, PKT_LEN(pkt), pkt->priority);
+            printk(KERN_DEBUG "avm_pa_pid_snoop_transmit: info->match.syn=%d, info->match.ack_only=%d, is_tcp=%d, pid->tget_enabled=%d, epid->tget_priority=0x%X, PKT_LEN(pkt)=%d, pkt->priority=%x\n", 
+                   info->match.syn, info->match.ack_only, is_tcp, epid->tget_enabled, epid->tget_priority, PKT_LEN(pkt), pkt->priority);
          }
          if (info->match.syn || info->match.fin || info->match.ack_only) {
-            epid->prioack_acks++;
             /* change TCP-Ack priority */
+            epid->prioack_acks++;
             if (pkt->priority > epid->prioack_priority) {
                pkt->priority = epid->prioack_priority;
                epid->prioack_accl_acks++;
                if (ctx->dbgprioacktrace) {
-                  printk(KERN_DEBUG "avm_pa_pid_snoop_transmit: reset priority to=%x\n", pkt->priority);
+                  printk(KERN_DEBUG "avm_pa_pid_snoop_transmit: reset tcpack priority to=%x\n", pkt->priority);
                }
             } 
+         } else if (is_tcp && epid->tget_enabled) {
+            /* change TCP-GET priority */
+            //epid->tgets ++;
+            if (info->can_be_accelerated && pkt->priority > epid->tget_priority) {
+               set_tget_prio = epid->tget_priority;
+               do_tget = 1;
+            } 
          }
       }
    }
    if (ctx->dbgprioacktrace && epid->prioack_enabled) 
-        printk(KERN_DEBUG "avm_pa_pid_snoop_transmit: priority=%x\n", pkt->priority);
+        printk(KERN_DEBUG "avm_pa_pid_snoop_transmit: priority=%x, epid->tget_enabled=%d, info->can_be_accelerated=%d\n", pkt->priority, epid->tget_enabled, info->can_be_accelerated);
 
    if (!info->can_be_accelerated) {
       ctx->stats.tx_bypass++;
@@ -4044,6 +4076,23 @@
             return AVM_PA_TX_ERROR_SESSION;
          }
       }
+
+      if (do_tget) {
+         if (ctx->dbgprioack) {
+            printk(KERN_DEBUG "avm_pa_pid_snoop_transmit: info->match.syn=%d, info->match.ack_only=%d, pid->tget_enabled=%d, PKT_LEN(pkt)=%d, pkt->priority=%x\n", 
+                   info->match.syn, info->match.ack_only, epid->tget_enabled, PKT_LEN(pkt), pkt->priority);
+         }
+         /* change TCP-GET priority */
+         epid->tgets ++;
+         if (pkt->priority > set_tget_prio) {
+            pkt->priority = set_tget_prio;
+            //epid->tget_accl++;
+            if (ctx->dbgprioack) {
+               printk(KERN_DEBUG "avm_pa_pid_snoop_transmit: reset tget priority to=%x\n", pkt->priority);
+            }
+         } 
+      }
+      
       /* Session State: CREATE */
       session->ingress_pid_handle = info->ingress_pid_handle;
       session->ingress_vpid_handle = info->ingress_vpid_handle;
@@ -4436,7 +4485,7 @@
                              pid->cfg.name,
                              pidflags2str(pid->ecfg.flags, buf, sizeof(buf)));
          if (pid->prioack_enabled)
-            (*fprintffunc)(arg, " ack prio 0x%x\n", pid->prioack_priority);
+            (*fprintffunc)(arg, " ack prio 0x%x (tget=%d, tget prio 0x%x)\n", pid->prioack_priority, pid->tget_enabled, pid->tget_priority);
          else
             (*fprintffunc)(arg, "\n");
       } else {
@@ -4451,7 +4500,7 @@
                              PA_PID(ctx, pid->ingress_pid_handle)->cfg.name,
                              pidflags2str(pid->ecfg.flags, buf, sizeof(buf)));
          if (pid->prioack_enabled)
-            (*fprintffunc)(arg, " ack prio 0x%x\n", pid->prioack_priority);
+            (*fprintffunc)(arg, " ack prio 0x%x (tget=%d, tget prio 0x%x)\n", pid->prioack_priority, pid->tget_enabled, pid->tget_priority);
          else
             (*fprintffunc)(arg, "\n");
       }
@@ -4629,6 +4678,8 @@
    }
    pid->prioack_enabled = enable ? 1 : 0;
    pid->prioack_priority = prio;
+   pid->tget_enabled = pid->prioack_enabled;
+   pid->tget_priority = prio-1;
    return 0;
 }
 EXPORT_SYMBOL(avm_pa_pid_activate_tcpackprio);
@@ -6120,7 +6171,6 @@
   
    seq_printf(seq, "Packet Threshold : %u\n",ctx->prioack_thresh_packets);
    seq_printf(seq, "Ratio            : %u\n",ctx->prioack_ratio);
-   seq_printf(seq, "ACK Size         : %u\n",ctx->prioack_packet_size);
    
    for (n=1; n < CONFIG_AVM_PA_MAX_PID; n++) {
       struct avm_pa_pid *pid = PA_PID(ctx, n);
@@ -6128,6 +6178,10 @@
       seq_printf(seq, "PID%d: ACK Priority     : %x\n",pid->pid_handle, pid->prioack_priority);
       seq_printf(seq, "PID%d: Detected ACKs    : %u\n",pid->pid_handle, pid->prioack_acks);
       seq_printf(seq, "PID%d: Accelerated ACKs : %u\n",pid->pid_handle, pid->prioack_accl_acks);
+      if (!pid->tget_enabled) continue;
+      seq_printf(seq, "PID%d: TGET Priority    : %x\n",pid->pid_handle, pid->tget_priority);
+      seq_printf(seq, "PID%d: Detected GETs    : %u\n",pid->pid_handle, pid->tgets);
+      seq_printf(seq, "PID%d: Accelerated GETs : %u\n",pid->pid_handle, pid->tget_accl);
    }
 
    return 0;
@@ -6572,6 +6626,8 @@
                   struct avm_pa_pid *pid = PA_PID(ctx, AVM_PA_DEVINFO(dev)->pid_handle);
                   pid->prioack_enabled = 1;
                   pid->prioack_priority = simple_strtoul(argv[3], 0, 10);
+                  pid->tget_enabled = 1;
+                  pid->tget_priority = pid->prioack_priority-1;
                   dev_put(dev);
                }
             }
@@ -6582,12 +6638,47 @@
                   struct avm_pa_pid *pid = PA_PID(ctx, AVM_PA_DEVINFO(dev)->pid_handle);
                   pid->prioack_enabled = 0;
                   pid->prioack_priority = 0;
+                  pid->tget_enabled = 0;
+                  pid->tget_priority = 0;
+                  dev_put(dev);
+               }
+            } else {
+               int n;
+               for (n=1; n < CONFIG_AVM_PA_MAX_PID; n++) {
+                  struct avm_pa_pid *pid = PA_PID(ctx, n);
+                  pid->prioack_enabled = 0;
+                  pid->prioack_priority = 0;
+                  pid->tget_enabled = 0;
+                  pid->tget_priority = 0;
+               }
+            }
+         } else if (strcmp(argv[1], "tgetenable") == 0) {
+            if (argv[2] && argv[3]) {
+               struct net_device *dev = dev_get_by_name(&init_net, argv[2]);
+               if (dev) {
+                  struct avm_pa_pid *pid = PA_PID(ctx, AVM_PA_DEVINFO(dev)->pid_handle);
+                  pid->tget_enabled = 1;
+                  pid->tget_priority = simple_strtoul(argv[3], 0, 10);
                   dev_put(dev);
                }
             }
-         } else if (strcmp(argv[1], "psize") == 0) {
-            if (argv[2]) val = simple_strtoul(argv[2], 0, 10);
-            if (val) ctx->prioack_packet_size = val;
+         } else if (strcmp(argv[1], "tgetdisable") == 0) {
+            if (argv[2]) {
+               struct net_device *dev = dev_get_by_name(&init_net, argv[2]);
+               if (dev) {
+                  struct avm_pa_pid *pid = PA_PID(ctx, AVM_PA_DEVINFO(dev)->pid_handle);
+                  pid->tget_enabled = 0;
+                  pid->tget_priority = 0;
+                  dev_put(dev);
+               }
+            } else {
+               int n;
+               for (n=1; n < CONFIG_AVM_PA_MAX_PID; n++) {
+                  struct avm_pa_pid *pid = PA_PID(ctx, n);
+                  pid->tget_enabled = 0;
+                  pid->tget_priority = 0;
+               }
+            }
          } else if (strcmp(argv[1], "pthresh") == 0) {
             if (argv[2]) val = simple_strtoul(argv[2], 0, 10);
             if (val) ctx->prioack_thresh_packets = val;
--- linux-2.6.32/net/ipv4/tcp_input.c	2013-02-12 12:29:49.000000000 +0100
+++ linux-2.6.32/net/ipv4/tcp_input.c	2019-07-09 15:36:56.000000000 +0200
@@ -74,7 +74,7 @@
 
 int sysctl_tcp_timestamps __read_mostly = 1;
 int sysctl_tcp_window_scaling __read_mostly = 1;
-int sysctl_tcp_sack __read_mostly = 1;
+int sysctl_tcp_sack __read_mostly = 0;
 int sysctl_tcp_fack __read_mostly = 1;
 int sysctl_tcp_reordering __read_mostly = TCP_FASTRETRANS_THRESH;
 int sysctl_tcp_ecn __read_mostly = 2;
--- linux-2.6.32/net/ipv4/tcp_output.c	2013-10-22 18:53:31.000000000 +0200
+++ linux-2.6.32/net/ipv4/tcp_output.c	2019-07-09 15:36:56.000000000 +0200
@@ -983,6 +983,9 @@
 	/* Now subtract TCP options size, not including SACKs */
 	mss_now -= tp->tcp_header_len - sizeof(struct tcphdr);
 
+	/* CVE-2019-11479: set mss to 536 minimum */
+	mss_now = max(mss_now, 536);
+
 	return mss_now;
 }
 
--- linux-2.6.32/net/ipv4/tcp_timer.c	2011-05-25 15:51:48.000000000 +0200
+++ linux-2.6.32/net/ipv4/tcp_timer.c	2019-07-09 15:36:56.000000000 +0200
@@ -126,6 +126,8 @@
 			mss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1;
 			mss = min(sysctl_tcp_base_mss, mss);
 			mss = max(mss, 68 - tp->tcp_header_len);
+			/* CVE-2019-11479: set mss to 536 minimum */
+			mss = max(mss, 536);
 			icsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);
 			tcp_sync_mss(sk, icsk->icsk_pmtu_cookie);
 		}
